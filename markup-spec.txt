=text markup language primarily useful for prose documents such as books, articles
=designed to=editable in plain text editor (at least to extent that Emacs ?=considered plain text editor), to allow for arbitrary logical markup
grammar of  file=defined in terms of mapping to abstract syntax tree which ? then=rendered into number of formats, e.g. HTML, PDF, TeX, RTF, etc.
 files consist of Unicode text encoded in UTF-8
Lines ?=terminated with carriage return (U+000D), carriage-return/line-feed (U+000D U+000A), line feed (U+000A)
Tab characters (U+0009)=equivalent to 8 spaces
blank line (which has syntactic meaning to=described later)=defined as 2 consecutive end-of-line sequences /?/ with white space between end-of-line sequences
Trailing white space has no meaning, not need to=preserved by processor
basic syntax=similar to Markdown, reStructuredText with bit of TeX thrown in for good measure
As mentioned above, grammar defines mapping between document, abstract syntax tree
tree=built out of tagged elements, strings
=originally developed in Lisp where obvious representation for document=as s-expressions, with each tree represented by list whose first element=symbol indicating tree’s tag
This kind of tree structure also has obvious representation in XML/HTML
abstract syntax tree=rooted in single element whose tag=`body`
abstract syntax tree children=elements described below
element names chosen so that trivial mapping to HTML gives useful result but other than that pleasant coincidence, defines no particular semantics for documents
Normal paragraphs=blocks of text separated by /+/ blank lines
Normal paragraphs ? contain single line breaks, which=converted to spaces during parsing
body of paragraph ? contain tagged markup as discussed below
tag of paragraph node=`p`
Headers=paragraphs marked as in Emacs outline-mode, with leading `*`s followed by 1 space
more stars lower in hierarchy header
content of header=everything after `*`, space, =otherwise parsed just like paragraph
Header nodes=tagged with `hn` where n=number of stars
Block quotes=1 of 3 kinds of “sections” indicated by indentation
section ends at end of file/by occurrence of less-indented non-blank line
Sections ? also=nested
block quote=demarcated by 2 spaces of indentation relative to enclosing section, ? contain paragraphs, headers, lists, verbatim sections
Block quote nodes=tagged with `blockquote`
Verbatim sections=indented 3 spaces relative to enclosing section
Within verbatim section all text=captured exactly as is
Verbatim sections=tagged with `pre`
Lists=demarcated by 2 spaces of indentation followed by list marker, either `#` for ordered (i.e. numbered) list/`-` for unordered (i.e. bulleted) list
ordered list=tagged with `ol`, unordered list with `ul`
list marker=followed by space, then text of 1st list item
List items=tagged with `li`, ? contain multiple paragraphs, contents of which=indented to line up under 1st character of beginning of list item
Subsequent items=marked with another list marker in same column as original list marker, 1 space
 processor ? optionally support few bits of syntax to make more convenient to add hyperlinks to document
Within normal text (i.e. anywhere but verbatim section) link ?=indicated by enclosing text to act as hyperlink with `[]`s
enclosing text to act as hyperlink with `[]`s maps to element tagged `link`
If text between `[]`s includes `|`, text after `|`=wrapped in `key` element
paragraph consisting solely of text in `[]`s followed by /*/ spaces followed by text enclosed in `<>`s=parsed as element tagged `link_def` whose 2 children=`link` element comprising text between `[]`s, `url` element comprising text between `<>`s
idea=that backend render all in-text `link` elements as hyperlinks with `link` text linking to URL given in corresponding `link_def` element
given processor ? choose to implement link syntax/not, if  processor does, ? provide way to indicate whether/not link syntax should=used when parsing given document
For all other markup, uses TeX-like notation `\tagname{stuff}`
Tag names ? consist of letters, numbers, `-`, `.`, `+`
Tagged markup ? nest so ? have:
   \i{italic with \b{some bold added}, back to just italic}
element created from tagged markup=tagged with tagname
Certain tag names ?=used to mark sub-documents which=parsed differently than simple spans of text
content of sub-document—between opening, closing {}s—is parsed like document so=contain /+/ paragraph, ?contain headers, block quotes, lists, verbatim sections, even nested sub-documents
Footnotes, for example,=commonly set up to=parsed as sub-documents
Note that blank line separating paragraphs of sub-document has no effect on enclosing paragraph
If sub-document=embedded in paragraph that=part of indented section (i.e. block quote/list) then subsequent lines of sub-document should=indented same as enclosing paragraph:
processor=need to provide some more/less convenient way to specify that certain tag names should=parsed as sub-documents rather than character markup
Outside of verbatim sections, backslash ? escape any character that=not legal tag name character, stripping any character of syntactic significance
characters `\`, `{`, `}` must=escaped whenever `\`, `{`, `}` appear outside verbatim section if they=to=part of text
Other non-tag-name characters may=escaped anytime, but only necessary when non-tag-name characters would otherwise have syntactic significance
For example, `*` does not need to=escaped except at beginning of paragraph, where `*` would otherwise mark paragraph as header
In real world,  documents=often (usually) edited in Emacs
Emacs has mechanism whereby line starting with `-*-` indicates \i{mode line} which tells emacs about how to edit file
For instance, in  sources of specification, first line is:
   -*- mode: markup; -*-
parser ? choose to strip such modelines at top level of document to save having to strip such modelines out later in processing
complete system consists of parser that ? parse text file in syntax into data structure representing resulting abstract syntax tree, /+/ back-ends that ? render such tree into some other form
For purposes of testing specify trivial mapping from  abstract tree to well-formed XML: each  element=mapped to XML element with same name, with node children mapped to XML in same way, string children as text
