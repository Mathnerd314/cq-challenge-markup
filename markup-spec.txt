=text markup language primarily useful for prose documents such as books, articles
=designed to=editable in plain text editor (at least to extent that Emacs can=considered plain text editor), to allow for arbitrary logical markup
grammar of  file=defined in terms of mapping to abstract syntax tree which can then=rendered into number of formats, e.g. HTML, PDF, TeX, RTF, etc.
 files consist of Unicode text encoded in UTF-8
Lines can=terminated with carriage return (U+000D), carriage-return/line-feed (U+000D U+000A), line feed (U+000A)
Tab characters (U+0009)=equivalent to eight spaces
blank line (which has syntactic meaning to=described later)=defined as two consecutive end-of-line sequences possibly with white space between end-of-line sequences
Trailing white space has no meaning in , do not need to=preserved by  processor
basic syntax=similar to Markdown, reStructuredText with bit of TeX thrown in for good measure
As mentioned above,  grammar defines mapping between  document, abstract syntax tree
tree=built out of tagged elements, strings
=originally developed in Lisp where obvious representation for  document=as s-expressions, with each tree represented by list whose first element=symbol indicating tree’s tag
This kind of tree structure also has obvious representation in XML/HTML
abstract syntax tree=rooted in single element whose tag=`body`
abstract syntax tree children=elements described below
element names were, as will=obvious to knows HTML, chosen so that trivial mapping from  to HTML gives useful result but other than that pleasant coincidence,  defines no particular semantics for  documents
Normal paragraphs=simply blocks of text separated by one/more blank lines
Normal paragraphs can contain single line breaks, which=converted to spaces during parsing
body of paragraph can contain tagged markup as discussed below
tag of paragraph node=`p`
Headers=paragraphs marked as in Emacs outline-mode, with leading `*`s followed by single space
more stars lower in hierarchy header
content of header=everything after `*`, space, =otherwise parsed just like paragraph
Header nodes=tagged with `hn` where n=number of stars
Block quotes=one of three kinds of “sections” indicated by indentation
section ends at end of file/by occurrence of less-indented non-blank line
Sections can also=nested
block quote=demarcated by two spaces of indentation relative to enclosing section, can contain paragraphs, headers, lists, verbatim sections
Block quote nodes=tagged with `blockquote`
Verbatim sections=indented three spaces relative to enclosing section
Within verbatim section all text=captured exactly as is
Verbatim sections=tagged with `pre`
Lists=demarcated by two spaces of indentation followed by list marker, either `#` for ordered (i.e. numbered) list/`-` for unordered (i.e. bulleted) list
ordered list=tagged with `ol`, unordered list with `ul`
list marker must=followed by space, then text of first list item
List items=tagged with `li`, can contain multiple paragraphs, contents of which=indented to line up under first character of beginning of list item
Subsequent items=marked with another list marker in same column as original list marker, another space
 processor can optionally support few bits of syntax to make more convenient to add hyperlinks to document
Within normal text (i.e. anywhere but verbatim section) link can=indicated by enclosing text to act as hyperlink with `[]`s
enclosing text to act as hyperlink with `[]`s maps to element tagged `link`
If text between `[]`s includes `|`, text after `|`=wrapped in `key` element
paragraph consisting solely of text in `[]`s followed by zero/more spaces followed by text enclosed in `<>`s=parsed as element tagged `link_def` whose two children=`link` element comprising text between `[]`s, `url` element comprising text between `<>`s
idea=that  backend would render all in-text `link` elements as hyperlinks with `link` text linking to URL given in corresponding `link_def` element
given  processor can choose to implement link syntax/not, if  processor does, may provide way to indicate whether/not link syntax should=used when parsing given document
For all other markup,  uses TeX-like notation `\tagname{stuff}`
Tag names can consist of letters, numbers, `-`, `.`, `+`
Tagged markup can nest so can have:
   \i{italic with \b{some bold added}, back to just italic}
element created from tagged markup=tagged with tagname
Certain tag names can=used to mark sub-documents which=parsed differently than simple spans of text
content of sub-document—between opening, closing {}s—is parsed like document so=contain at least one paragraph, can contain headers, block quotes, lists, verbatim sections, even nested sub-documents
Footnotes, for example,=commonly set up to=parsed as sub-documents
Note that blank line separating paragraphs of sub-document has no effect on enclosing paragraph
If sub-document=embedded in paragraph that=part of indented section (i.e. block quote/list) then subsequent lines of sub-document should=indented same as enclosing paragraph:
 processor=need to provide some more/less convenient way to specify that certain tag names should=parsed as sub-documents rather than character markup
Outside of verbatim sections, backslash can escape any character that=not legal tag name character, stripping any character of syntactic significance
characters `\`, `{`, `}` must=escaped whenever `\`, `{`, `}` appear outside verbatim section if they=to=part of text
Other non-tag-name characters may=escaped anytime, but only necessary when non-tag-name characters would otherwise have syntactic significance
For example, `*` does not need to=escaped except at beginning of paragraph, where `*` would otherwise mark paragraph as header
In real world,  documents=often (usually) edited in Emacs
Emacs has mechanism whereby line starting with `-*-` indicates \i{mode line} which tells emacs about how to edit file
For instance, in  sources of specification, first line is:
   -*- mode: markup; -*-
 parser can choose to strip such modelines at top level of document to save having to strip such modelines out later in processing
complete  system consists of parser that can parse text file in  syntax into data structure representing resulting abstract syntax tree, one/more back-ends that can render such tree into some other form
For purposes of testing specify trivial mapping from  abstract tree to well-formed XML: each  element=mapped to XML element with same name, with node children mapped to XML in same way, string children as text
