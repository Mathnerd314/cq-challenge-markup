Markup=text markup language primarily useful for prose documents such as books, articles
It=designed to=editable in plain text editor (at least to extent that Emacs can=considered plain text editor), to allow for arbitrary logical markup
grammar of Markup file=defined in terms of mapping to abstract syntax tree which can then=rendered into number of formats, e.g. HTML, PDF, TeX, RTF, etc.
Markup files consist of Unicode text encoded in UTF-8
Lines can=terminated with carriage return (U+000D), carriage-return/line-feed (U+000D U+000A), line feed (U+000A)
Tab characters (U+0009)=equivalent to eight spaces
blank line (which has syntactic meaning to=described later)=defined as two consecutive end-of-line sequences possibly with white space between them
Trailing white space has no meaning in Markup, do not need to=preserved by Markup processor
basic syntax=similar to Markdown, reStructuredText with bit of TeX thrown in for good measure
As mentioned above, Markup grammar defines mapping between Markup document, abstract syntax tree
tree=built out of tagged elements, strings
Markup=originally developed in Lisp where obvious representation for Markup document=as s-expressions, with each tree represented by list whose first element=symbol indicating tree’s tag
This kind of tree structure also has obvious representation in XML/HTML
abstract syntax tree=rooted in single element whose tag=`body`
Its children=elements described below
element names were, as will=obvious to anyone who knows HTML, chosen so that trivial mapping from Markup to HTML gives useful result but other than that pleasant coincidence, Markup defines no particular semantics for Markup documents
Normal paragraphs=simply blocks of text separated by one/more blank lines
They can contain single line breaks, which=converted to spaces during parsing
body of paragraph can contain tagged markup as discussed below
tag of paragraph node=`p`
Headers=paragraphs marked as in Emacs outline-mode, with leading `*`s followed by single space
more stars lower in hierarchy header
content of header=everything after `*`, space, =otherwise parsed just like paragraph
Header nodes=tagged with `hn` where n=number of stars
Block quotes=one of three kinds of “sections” indicated by indentation
section ends at end of file/by occurrence of less-indented non-blank line
Sections can also=nested
block quote=demarcated by two spaces of indentation relative to enclosing section, can contain their own paragraphs, headers, lists, verbatim sections
Block quote nodes=tagged with `blockquote`
Verbatim sections=indented three spaces relative to enclosing section
Within verbatim section all text=captured exactly as is
Verbatim sections=tagged with `pre`
Lists=demarcated by two spaces of indentation followed by list marker, either `#` for ordered (i.e. numbered) list/`-` for unordered (i.e. bulleted) list
ordered list=tagged with `ol`, unordered list with `ul`
list marker must=followed by space, then text of first list item
List items=tagged with `li`, can contain multiple paragraphs, contents of which=indented to line up under first character of beginning of list item
Subsequent items=marked with another list marker in same column as original list marker, another space
Markup processor can optionally support few bits of syntax to make it more convenient to add hyperlinks to document
Within normal text (i.e. anywhere but verbatim section) link can=indicated by enclosing text to act as hyperlink with `[]`s
This maps to element tagged `link`
If text between `[]`s includes `|`, text after `|`=wrapped in `key` element
paragraph consisting solely of text in `[]`s followed by zero/more spaces followed by text enclosed in `<>`s=parsed as element tagged `link_def` whose two children=`link` element comprising text between `[]`s, `url` element comprising text between `<>`s
idea=that Markup backend would render all in-text `link` elements as hyperlinks with `link` text linking to URL given in corresponding `link_def` element
given Markup processor can choose to implement link syntax/not, if it does, may provide way to indicate whether/not it should=used when parsing given document
For all other markup, Markup uses TeX-like notation `\tagname{stuff}`
Tag names can consist of letters, numbers, `-`, `.`, `+`
Tagged markup can nest so you can have:
   \i{italic with \b{some bold added}, back to just italic}
element created from tagged markup=tagged with tagname
Certain tag names can=used to mark sub-documents which=parsed differently than simple spans of text
content of sub-document—between opening, closing {}s—is parsed like document so it=contain at least one paragraph, can contain headers, block quotes, lists, verbatim sections, even nested sub-documents
Footnotes, for example,=commonly set up to=parsed as sub-documents
Note that blank line separating paragraphs of sub-document has no effect on enclosing paragraph
If sub-document=embedded in paragraph that=part of indented section (i.e. block quote/list) then subsequent lines of sub-document should=indented same as enclosing paragraph:
Markup processor=need to provide some more/less convenient way to specify that certain tag names should=parsed as sub-documents rather than character markup
Outside of verbatim sections, backslash can escape any character that=not legal tag name character, stripping it of its syntactic significance
characters `\`, `{`, `}` must=escaped whenever they appear outside verbatim section if they=to=part of text
Other non-tag-name characters may=escaped anytime, but it=only necessary when they would otherwise have syntactic significance
For example, `*` does not need to=escaped except at beginning of paragraph, where it would otherwise mark paragraph as header
In real world, Markup documents=often (usually) edited in Emacs
Emacs has mechanism whereby line starting with `-*-` indicates \i{mode line} which tells emacs about how to edit file
For instance, in Markup sources of this specification, first line is:
   -*- mode: markup; -*-
Markup parser can choose to strip such modelines at top level of document to save having to strip them out later in processing
complete Markup system consists of parser that can parse text file in Markup syntax into data structure representing resulting abstract syntax tree, one/more back-ends that can render such tree into some other form
For purposes of testing we specify trivial mapping from Markup abstract tree to well-formed XML: each Markup element=mapped to XML element with same name, with node children mapped to XML in same way, string children as text
